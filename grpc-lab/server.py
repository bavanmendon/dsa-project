import grpc
from concurrent import futures
import myitems_pb2
import myitems_pb2_grpc
from grpc_reflection.v1alpha import reflection

items = [
	{"id": 1, "name": "Name 1"},
	{"id": 2, "name": "Name 2"},
	{"id": 3, "name": "Name 3"}
]

# ID counter for new objects
current_id = 4

class LoggingInterceptor(grpc.ServerInterceptor):
	def intercept_service(self, continuation, handler_call_details):
		method = handler_call_details.method
		metadata = handler_call_details.invocation_metadata
		print(f"Received call to method: {method} with metadata: {metadata}")
		return continuation(handler_call_details)

# server = grpc.server(
# 	futures.ThreadPoolExecutor(max_workers=10),
# 	interceptors = [LoggingInterceptor()]
# )

# service_names = (
# 	myitems_pb2.DESCRIPTOR.services_by_name['ItemService'].full_name,
# 	reflection.SERVICE_NAME
# )

class ItemService(myitems_pb2_grpc.ItemServiceServicer):											# Links to class auto-generated by grpc (pb2_grpc), within class, mainly uses pb2)
	def GetItemById(self, request, context):
		# unary
		# search for item with matching ID
		for item in items:
			if item["id"] == request.id:																	# Look for data with the ID requested by Client and return that value
				return myitems_pb2.ItemResponse(id = item["id"], name = item["name"])
		context.set_code(grpc.StatusCode.NOT_FOUND)															# Error code when client requests for something that doesn't exist
		context.set_details("Item not found")
		return myitems_pb2.ItemResponse()	# Return empty response if not found

	def ListAllItems(self, request, context):
		# server-streaming
		# Request by client to list all data in 'items'
		for item in items:
			yield myitems_pb2.ItemResponse(id = item["id"], name = item["name"])							# Send each data point from 'items' to client

	def AddItems(self, request_iterator, context):
		# client-streaming
		global current_id																					# Sets indexing for new data to be appended
		count = 0
		for new_item in request_iterator:
			# Avoid duplicate IDs
			print(f"Processing item {new_item.name}")
			#if not any(item["id"] == req.id for item in items):
			items.append({"id": current_id, "name": new_item.name})											# Append new data from client to 'items'
			current_id += 1																					# Increment index to current 'id'
			count += 1																						# Keeps count of total newly added items received from client
		return myitems_pb2.ItemsAddedResult(total_count = count)

	def ChatAboutItems(self, request_iterator, context):
		# bidirectional
		for chat_message in request_iterator:
			# Echo back the received message (you can add more logic here)
			print(f"[{chat_message.user}]: {chat_message.message}")											# Print received messages from client stream
			yield myitems_pb2.ChatMessage(user = "Server", message = f"Received: {chat_message.message}")				# Stream server messages to client

def serve():
	server = grpc.server(
	futures.ThreadPoolExecutor(max_workers=10),
	interceptors = [LoggingInterceptor()]
)
	myitems_pb2_grpc.add_ItemServiceServicer_to_server(ItemService(), server)

	service_names = (
	myitems_pb2.DESCRIPTOR.services_by_name['ItemService'].full_name,
	reflection.SERVICE_NAME
)
	
	reflection.enable_server_reflection(service_names, server)
	server.add_insecure_port('[::]:50051')
	server.start()
	print("gRPC server runing on port 50051")


	
	server.wait_for_termination()

if __name__ == '__main__':
	serve()
	
